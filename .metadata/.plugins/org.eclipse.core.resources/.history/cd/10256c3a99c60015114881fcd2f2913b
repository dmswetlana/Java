// строки в java представляют собой классы

import static java.lang.System.out;
//обычный импорт импортирует обычный класс,
//например: import java.util.Date; (импортируем класс Date)
// Статический импорт импортирует поле или метод класса
//поэтому прописываем полный путь к статическому полю out
// import static java.lang.System.out;

import java.util.Scanner;
//используем класс Scanner для ввода с консоли.
//Он позволяет работать с любым потоком и читать строковые
//данные, числовые данные.

import java.util.Date;

public class Strings {

	public static void main(String[] args){ 
	{	
		String s1 = "Привет"; //в s1 содержится адрес строки
		String s2 = new String("Привет");
		
		//объекты класса строки являются неизменяемыми
	
		char ch = s1.charAt(0); //этот метод позволяет получить символ строки
		                       //по его порядковому номеру
		out.println(s1);
		out.println(ch);
		
		String hello = "Привет";
		String name = "Сергей";
		String result = hello + " " + name.toUpperCase(); 
		//метод toUpperCase() переводит строку в верхний регистр 
		
		out.println(result);
	}
/*	{
		//формируем строку из 100 чисел через пробел
		//это решение BAD, так писать не нужно
		//создаётся в памяти 302 объекта класса String
		// Работает медленно
		String r = ""; //создали пустую строку
		for (int i=1; i<=100; i++)
		r = r + String.valueOf(i) + " "; //число i переводим в строку
		out.println(r);
		
		
		StringBuilder sb = new StringBuilder(); //этот класс StringBuilder не создаёт 
		                                        //в памяти новых классов, а изменяет
		                                        //существующий
		for (int i=1; i<=100; i++)
			sb.append(i).append(" "); //метод append возвращает ссылку на этот же объект
			
		//результат получаем не String a StringBuilger, поэтому
		//методом toString делаем проеобразование к String
			String r = sb.toString();
			out.println(sb);
	*/	{	
		//рассмотрим ввод с консоли
			Scanner sc = new Scanner(System.in);
			out.print("Введите строку: ");
			String s = sc.nextLine(); //метод nextLine возвращает строку,
			                          //введённую с консоли
			out.println(s);
			
		//рассмотрим сравнение строк
			String s3="Sergey";
			boolean rs = (s == s3); //сравниваются адреса, а не значения
			out.println(rs);
	
				
		//в java строки стравниваются методом equals
			
			boolean rs1 = (s.equals(s3)); //сравнивается содержимое строк
			out.println(rs1);		
			}
		{
		String s1 = "Привет"; //В памяти будет одна строка. Компилятор соптимизировал.
		String s2 = "Привет"; //Здесь два объекта содержат одинаковые адреса
		
		boolean r = (s1 == s2);
		out.println(r);
		
		String s3 = new String ("Привет"); //Здесь создаются два объекта
		String s4 = "Привет";              //new всегда создаёт новый объект
		                                   //адреса объектов разные
		r = (s3 == s4);
		out.println(r);
		
		String s5 = "Привет";           //адреса будут равны
		String s6 = "При" + "вет";      //объект будет один, как в первом случае
		r = (s5 == s6);
		out.println(r);
		
		String s7 = "Привет";        //адреса не будут равны
		String s8 = "вет";           //компилятор оптимизацию выполнять не будет.
		String s9 = "При" + s8;      //в выражении есть не только литералы, но и переменные
		r = (s7 == s9);
		out.println(r);
		
		}
	
		{
			//вывод в консоль
			int a=5;
			int b=7;
			
			out.printf("\"a\"= %d\nb= %d\n", a, b);
			 double d=25;
			 double d2=1.5;
			 
			 out.printf("d= %2$10.2f\nd2=%1$f\n", d2, d/2);
			 //сначала печатаем второе значение, потом первое
			 
			Date now = new Date();
			out.printf("%1$tY-%2$tB-%1$tD", now);
			
		}
	
	}
}
